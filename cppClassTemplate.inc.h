/*
 *  cppClassTemplate.h
 *  ddl2cpp
 *
 *  C++ class template as strings, intended to be populated
 *  with database fields and accessors, parsed from a DDL (SQLite) description.
 *
 *  Created by Mathias Franck on 02/03/12.
 *  Copyright 2012 Vidal. All rights reserved.
 *
 */


static const wstring cppPrologue=L"\
/*\n\
*  $className.hxx\n\
*  \n\
*  C++ mapping generated by ddl2cpp (written by Mathias Franck).\n\
*  $generationDateTime\n\
*  Copyright 2012 Vidal. All rights reserved.\n\
*\n\
*/\n\n\
#ifndef $className_HXX\n\
#define $className_HXX\n\n\
#include <iostream>\n\
#include <string>\n\
#include <memory>\n\
#include <vector>\n\
#include <odb/core.hxx>\n\
#include <odb/tr1/memory.hxx>\n\
#include <odb/lazy-ptr.hxx>\n\
\n\
using std::tr1::shared_ptr;\n\
using odb::lazy_auto_ptr;\n\
using namespace std;\n\
\n\
namespace FastAPI {\n\
\n\
#pragma db object table(\"$tableName\") \n\
	class $className\n\
	{\n";
static const wstring cppAccessors=L"\
	public:\n";
static const wstring cppFields=L"\
	private:\n\
		friend class odb::access;\n\
		$className() {} // read-only objects should only be created from db !\n";
static const wstring pragmaID=L"#pragma db id\n";
static const wstring pragmaRole=L"#pragma db column(\"$roleColumn\")\n";

static const wstring pragmaNull=L"#pragma db null\n";
static const wstring cppEpilogue=L"\
	};\n\
};\n\
#endif";

inline void replaceAll(const wstring& pattern, const wstring& word, wstring& target) {
	size_t pos=0;
	do {
			pos=target.find(pattern);
			if (pos!=wstring::npos) {
				target.replace(pos,pattern.size(),word);
			}
	} while (pos!=wstring::npos);
}

inline wstring camelize(const wstring& target) {
	wstring result=target;
	result.replace(0,1,1,towupper(target[0]));
	return result;
}

inline wstring trimQuotes(const wstring& target) { //vire la quote de debut et de fin si besoin
	wstring result;
	int deb=0;
	int keep=target.size();
	if (target.size()>2) {
		if (target[target.size()-1]==L'"') keep--;
		if (target[0]==L'"') { deb++; keep--;}
	}
	return result.assign(target,deb,keep);
}
typedef map<wstring,wstring> FieldTypes;
typedef map<wstring,wstring> RoleMap; //mapper les cles etrangères avec les clés primaires, si elles different

